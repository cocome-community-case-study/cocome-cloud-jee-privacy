\chapter{System Adaptation}
\label{ch:SysAdap}

In the system adaptation stage of the iObserve Privacy pipeline the current software system is modified to match the re-deployment PCM. This filer stage represents part of the planning and the complete execution phase of the MAPE loop (\autoref{sec:Foundations:mape}).

The remainder of this chapter is structured into adaptation planning and the actual adaptation execution. It closes with a look onto the implementation.


\section{Adaptation Planning}
\label{sec:SysAdap:plan}

The planning phases job is to calculate what actions are required to bring the observed software system into the state defined by the redeployment model. While the task is pretty clear, the available source of informations are quite uncertain.

There are multiple potential sources of information that can be used to calculate adaptation steps. For example the \textit{Design Decisions} file used and modified by PerOpteryx (\autoref{ch:PerOpt}). This file contains all choices made during generation of the redeployment model. These informations are a viable source for action computation, however create a strong dependency on PerOpteryx. This means, if PerOpteryx would be exchanged for another model optimization tool, the complete adaptation planning needs to be rewritten.

Another information source for the adaptation planning could be the close observation of the candidate calculation/generation. This could be achieved by logging decisions made by the evolutionary algorithm. When considering, that the starting point of an evolutionary algorithms is usually a given input, the modification steps could be traced and remodelled for the system adaptation. However, evolutionary algorithms usually don't take the shortest path onto their end result and also random mutations are an valid generation factor. This means, the results needs to be analysed and optimized, while also injecting observations probes. While being a good potential information source, the effort for post-generation analysis and the resulting dependencies make it a bad choice.

We decided to make a direct comparison of the runtime PCM and the redeployment PCM. This builds up no further dependencies and the shortest adaptation path can be found. However, the information preprocessing and the comparison algorithm can be more complex than the other options.

\subsection{Adaptation Actions}
Palladio models are independent from programming languages, technologies and other specifics. We decided to enforce this characteristic by defining technology independent actions. They contain the required information, without knowing anything about the used technologies.

Further, we designed a set of basic actions which allows us to transform any PCM into another. The actions can be grouped into two major disjunct subgroups: the \textit{Assembly Context Actions} and the \textit{Resource Container Actions}.

\begin{itemize}
	\label{enum:SysAdap:plan:actions}
	\setlength\itemsep{0em}
	\item \textbf{Assembly Context Actions}
	\begin{itemize}
		\setlength\itemsep{0em}
		\item Allocate Action
		\item Deallocate Action
		\item Migrate Action
		\item Change Repository Component Action
	\end{itemize}
	\item \textbf{Resource Container Actions}
	\begin{itemize}
		\setlength\itemsep{0em}
		\item Acquire Action
		\item Replicate Action
		\item Terminate Action
	\end{itemize}
\end{itemize}

Assembly Context Actions reflect all model changes around a software component. Allocate, Deallocate and Migration Actions are self explaining. The Change Repository Component Action addresses the possibility to exchange a software component with an equivalent one. This can due to better fitting performance characteristics, while required and provided interfaces stay the same. As a result, the structure of the system model stays unchanged, but an encapsulated component gets exchanged for another one.

Resource Container Actions reflect changes around a virtual or physical server. Acquire and Terminate Actions don't need any explanations. A Replicate Action clones a server instance with its containing components.

\subsection{Action Ordering}

After all required actions are determined, an order must be established. We decided for the most simple but effective approach: "acquire, migrate, terminate." Meaning, first acquire the new servers, change the component allocations and finally terminate the unnecessary servers. This way no component get moved onto non-existent servers.

\todo{add conditions for actions and generate universal order!}


\todo{More details and thought on ordering!}



\section{Adaptation Execution}
\label{sec:SysAdap:exec}

The adaptation execution is as straight forward as it gets. The actions get executed - in order determined by adaptation planning (\autoref{sec:SysAdap:plan}) - by calling equivalent scripts, which wrap the technological side of the action. The technological implications are not considered by this thesis and are therefore not further discussed.
\todo{Ref to PÃ¶ppke?}
\todo{More details, when scripts \& implementation are rdy?}



\section{Implementation}
\label{sec:SysAdap:impl}


The implementation is split into three parts: the action calculation, the action ordering and the action execution. The calculation is based on the same graph as used during the \textit{Privacy Analysis} (\autoref{fig:privacy_graph_mm}). The Assembly Context Actions get calculated independently from the Resource Container Actions, the principle however is the same:

\begin{algorithm}[h]
	\caption{Action Calculation algorithm}
	\label{algo:action_calc}
	\begin{algorithmic}[1]
		
		\State Dictionary $components$
		\State List of Action $actions$
		\State
		
		\Procedure{Init}{List<Components> $runtimeComponents$}
			\ForAll{$runComponent\gets runtimeComponents$}\State
			$components.$\Call{put}{$runComponent.AssemblyContextID$, $runComponent$ }
			\EndFor
		\EndProcedure
		\State
		\State
		\Procedure{CalculateActions}{List<Components> $reDeplComponents$}\State
			\ForAll{$reDeplComp\gets reDeplComponents$}\State
				$runComp\gets $ \Call{get}{$reDeplComp.AssemblyContextID$}
				
				\If {$runComp ==$ Null} \State
					$actions.$\Call{add}{ new $AllocateAction($\dots$)$ }
				\Else
					\If { $runComp.ComponentID$ != $reDeplComp.ComponentID$ }
						\State $actions.$\Call{add}{ new $ChangeRepoAction($\dots$)$ }
					\EndIf
					\If { $runComp.ResContainerID$ != $reDeplComp.ResContainerID$ }
						\State $actions.$\Call{add}{ new $MigrateAction($\dots$)$ }
					\EndIf
				\EndIf
				\State $components.$\Call{remove}{$reDeplComp.AssemblyContextID$}
			\EndFor
			\State
			\ForAll{$runComp\gets components$}
				\State $actions.$\Call{add}{ new $DeallocateAction($\dots$)$ }
			\EndFor
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Initially the algorithm adds all assembly components to a dictionary. In the main procedure, the algorithm iterates over all redeployment assembly components and tries to find a matching one in the runtime model. If no match as found, it is a new assembly component and needs to be allocated. If an equivalent was found, different comparison are made, to check whether adjustments have to made. Keep in mind, that the migration of a assembly component and the exchange of encapsulated repository component do not exclude each other. At the end of every iteration, the found runtime components get removed from the dictionary. At the end of the algorithm all remaining runtime assembly components are no longer required and can be deallocated. We need to point out, that the comparing operators are simplified for the purpose of a pseudo-code.

The calculation of the Resource Container Actions is implemented similar. Initially all servers get added to a dictionary, all redeployment servers get compared against those and the actions calculated accordingly.

The whole calculation is build around the stability of IDs on Palladio model elements. If the redeployment model creates a completely new system model, while changing only minor details, the calculation will deallocate the old system and allocate a totally new one. PerOpteryx modifies the system model, keeping the assembly context IDs - as intended - stable and therefore produces only minimal actions.

\todo{Check back with Replicate Action}

\todo{Describe Ordering}

\todo{Describe Execution}


