\chapter{System Adaptation}
\label{ch:SysAdap}

In the system adaptation stage of the iObserve Privacy pipeline the current software system is modified to match the re-deployment PCM. This filer stage represents part of the planning and the complete execution phase of the MAPE loop (\autoref{sec:Foundations:mape}).

The remainder of this chapter is structured into adaptation planning and the actual adaptation execution. It closes with a look onto the implementation.


\section{Adaptation Planning}
\label{sec:SysAdap:plan}

The planning phases job is to calculate what actions are required to bring the observed software system into the state defined by the redeployment model. While the task is pretty clear, the available source of informations are quite uncertain.

There are multiple potential sources of information that can be used to calculate adaptation steps. For example the \textit{Design Decisions} file used and modified by PerOpteryx (\autoref{ch:PerOpt}). This file contains all choices made during generation of the redeployment model. These informations are a viable source for action computation, however create a strong dependency on PerOpteryx. This means, if PerOpteryx would be exchanged for another model optimization tool, the complete adaptation planning needs to be rewritten.

Another information source for the adaptation planning could be the close observation of the candidate calculation/generation. This could be achieved by logging decisions made by the evolutionary algorithm. When considering, that the starting point of an evolutionary algorithms is usually a given input, the modification steps could be traced and remodelled for the system adaptation. However, evolutionary algorithms usually don't take the shortest path onto their end result and also random mutations are an valid generation factor. This means, the results needs to be analysed and optimized, while also injecting observations probes. While being a good potential information source, the effort for post-generation analysis and the resulting dependencies make it a bad choice.

We decided to make a direct comparison of the runtime PCM and the redeployment PCM. This builds up no further dependencies and the shortest adaptation path can be found. However, the information preprocessing and the comparison algorithm can be more complex than the other options.

\subsection{Adaptation Actions}
Palladio models are independent from programming languages, technologies and other specifics. We decided to enforce this characteristic by defining technology independent actions. They contain the required information, without knowing anything about the used technologies.

Further, we designed a set of basic actions which allows us to transform any PCM into another. The actions can be grouped into two major disjunct subgroups: the \textit{Assembly Context Actions} and the \textit{Resource Container Actions}.

\begin{itemize}
	\label{enum:SysAdap:plan:actions}
	\setlength\itemsep{0em}
	\item \textbf{Assembly Context Actions}
	\begin{itemize}
		\setlength\itemsep{0em}
		\item Allocate Action
		\item Deallocate Action
		\item Migrate Action
		\item Change Repository Component Action
	\end{itemize}
	\item \textbf{Resource Container Actions}
	\begin{itemize}
		\setlength\itemsep{0em}
		\item Acquire Action
		\item Replicate Action
		\item Terminate Action
	\end{itemize}
\end{itemize}

Assembly Context Actions reflect all model changes around a software component. Allocate, Deallocate and Migration Actions are self explaining. The Change Repository Component Action addresses the possibility to exchange a software component with an equivalent one. This can due to better fitting performance characteristics, while required and provided interfaces stay the same. As a result, the structure of the system model stays unchanged, but an encapsulated component gets exchanged for another one.

Resource Container Actions reflect changes around a virtual or physical server. Acquire and Terminate Actions don't need any explanations. A Replicate Action clones a server instance with its containing components.

\subsection{Action Ordering}

For each action a set of pre-execution-conditions can be determined. Out of this set, a universal order can be derived. However, we need two assumptions for this order to be valid:
\begin{enumerate}
	\setlength\itemsep{0em}
	\item Each component is affected by an action only once, except the \textit{ComonentExchangeAction}.
	\item A server never gets acquired an terminated in one sequence.
\end{enumerate}

If this two assumptions are true, a component always get directly allocated, migrated or terminated without any transitive movements. This means, the order inside a set of actions from the same type does not matter. Further, it states, that the order within all \textit{Assembly Context Actions} does not matter. The change component action is an exception.

\begin{table}[h]
	\centering
	\begin{tabular}{r | l}
		\hline
		\textbf{Action} & \textbf{Pre-Execution-Condition} \\
		\hline
		Allocate & execute after \textit{Acquire} \\
		Deallocate & execute before \textit{Terminate} \\
		Migrate & execute after \textit{Acquire} \& before \textit{Terminate} \\
		Acquire & -- \\
		Terminate & -- \\
		Replicate & -- \\
		\hline
	\end{tabular}
	\caption{Pre-Execution-Conditions for adaptation actions}
	\label{tab:SysAdap:cond}
\end{table}

The \textit{Change Repository Component Action} is missing, since it doesn't have a hard constraint. However, for execution it is more simple, to have a \textit{execute before Migrate} condition. The following order satisfies all the constraints (\autoref{tab:SysAdap:cond}):

\begin{table}[h]
	\centering
	\begin{tabular}{ r | c}
		\hline
		1 & Acquire\\
		2 & Change Component\\
		3 & Deallocate \& Allocate \& Migrate \\
		4 & Terminate \& Replicate\\
		\hline
	\end{tabular}
	\caption{Universal action execution order}
	\label{tab:SysAdap:order}
\end{table}

Due to our way of calculating the actions, by directly comparing the runtime and re-deployment model, our initially made assumptions are true. We therefore can use the order in \autoref{tab:SysAdap:order} as the universal action order.


\section{Adaptation Execution}
\label{sec:SysAdap:exec}

The adaptation execution is as straight forward as it gets. The actions get executed - in order determined by adaptation planning (\autoref{sec:SysAdap:plan}) - by calling equivalent scripts, which wrap the technological side of the action. The technological implications are not considered by this thesis and are therefore not further discussed.
\todo{Ref to PÃ¶ppke?}
\todo{More details, when scripts \& implementation are rdy?}



\section{Implementation}
\label{sec:SysAdap:impl}


The implementation is split into three parts: the action calculation, the action ordering and the action execution. The calculation is based on the same graph as used during the \textit{Privacy Analysis} (\autoref{fig:privacy_graph_mm}). The Assembly Context Actions get calculated independently from the Resource Container Actions, the principle however is the same:

\begin{algorithm}[h]
	\caption{Action Calculation algorithm}
	\label{algo:action_calc}
	\begin{algorithmic}[1]
		
		\State Dictionary $components$
		\State List of Action $actions$
		\State
		
		\Procedure{Init}{List<Components> $runtimeComponents$}
			\ForAll{$runComponent\gets runtimeComponents$}\State
			$components.$\Call{put}{$runComponent.AssemblyContextID$, $runComponent$ }
			\EndFor
		\EndProcedure
		\State
		\State
		\Procedure{CalculateActions}{List<Components> $reDeplComponents$}\State
			\ForAll{$reDeplComp\gets reDeplComponents$}\State
				$runComp\gets $ \Call{get}{$reDeplComp.AssemblyContextID$}
				
				\If {$runComp ==$ Null} \State
					$actions.$\Call{add}{ new $AllocateAction($\dots$)$ }
				\Else
					\If { $runComp.ComponentID$ != $reDeplComp.ComponentID$ }
						\State $actions.$\Call{add}{ new $ChangeRepoAction($\dots$)$ }
					\EndIf
					\If { $runComp.ResContainerID$ != $reDeplComp.ResContainerID$ }
						\State $actions.$\Call{add}{ new $MigrateAction($\dots$)$ }
					\EndIf
				\EndIf
				\State $components.$\Call{remove}{$reDeplComp.AssemblyContextID$}
			\EndFor
			\State
			\ForAll{$runComp\gets components$}
				\State $actions.$\Call{add}{ new $DeallocateAction($\dots$)$ }
			\EndFor
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Initially the algorithm adds all assembly components to a dictionary. In the main procedure, the algorithm iterates over all redeployment assembly components and tries to find a matching one in the runtime model. If no match as found, it is a new assembly component and needs to be allocated. If an equivalent was found, different comparison are made, to check whether adjustments have to made. Keep in mind, that the migration of a assembly component and the exchange of encapsulated repository component do not exclude each other. At the end of every iteration, the found runtime components get removed from the dictionary. At the end of the algorithm all remaining runtime assembly components are no longer required and can be deallocated. We need to point out, that the comparing operators are simplified for the purpose of a pseudo-code.

The calculation of the Resource Container Actions is implemented similar. Initially all servers get added to a dictionary, all redeployment servers get compared against those and the actions calculated accordingly.

The whole calculation is build around the stability of IDs on Palladio model elements. If the redeployment model creates a completely new system model, while changing only minor details, the calculation will deallocate the old system and allocate a totally new one. PerOpteryx modifies the system model, keeping the assembly context IDs - as intended - stable and therefore produces only minimal actions.

\todo{Check back with Replicate Action}

\todo{Describe Execution}


